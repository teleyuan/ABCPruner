┌─────────────────────────────────────────────────────────────────────────────────────────────┐
│                       ABCPruner 算法详细流程图（含所有循环关系）                              │
│                              bee_cifar.py 完整执行流程                                       │
└─────────────────────────────────────────────────────────────────────────────────────────────┘

═══════════════════════════════════════════════════════════════════════════════════════════════
                                    main() 函数入口
═══════════════════════════════════════════════════════════════════════════════════════════════

    ┌───────────────────────────────────────────────────────────────┐
    │  1. 加载数据集和预训练模型                                     │
    │     - loader = cifar10.Data(args)                             │
    │     - origin_model.load_state_dict(ckpt['state_dict'])        │
    │     - oristate_dict = origin_model.state_dict()               │
    └────────────────────────────┬──────────────────────────────────┘
                                 ↓
    ┌───────────────────────────────────────────────────────────────┐
    │  2. 判断是否需要 ABC 搜索                                      │
    │     if args.resume == None and args.best_honey == None:      │
    └────────────────────────────┬──────────────────────────────────┘
                                 ↓
                            [需要ABC搜索]

═══════════════════════════════════════════════════════════════════════════════════════════════
                            阶段 1: 初始化蜂群 initilize()
═══════════════════════════════════════════════════════════════════════════════════════════════

┌────────────────────────────────────────────────────────────────────────────────────────────┐
│ FOR循环 1: 初始化食物源                                                                     │
│ ───────────────────────────────────────────────────────────────────────────────────────── │
│ for i in range(args.food_number):     # 例如 food_number = 10                             │
│     ┌──────────────────────────────────────────────────────────────────────────────────┐  │
│     │ 食物源 i 的初始化流程                                                             │  │
│     │                                                                                   │  │
│     │ 1. 创建蜜蜂对象:                                                                  │  │
│     │    NectraSource[i] = BeeGroup()                                                   │  │
│     │    EmployedBee[i] = BeeGroup()                                                    │  │
│     │    OnLooker[i] = BeeGroup()                                                       │  │
│     │                                                                                   │  │
│     │ 2. FOR循环 1.1: 生成随机编码                                                      │  │
│     │    ┌────────────────────────────────────────────────────────────────────────┐   │  │
│     │    │ for j in range(food_dimension):  # 例如 ResNet56: 27维                 │   │  │
│     │    │     NectraSource[i].code[j] = random.randint(1, args.max_preserve)     │   │  │
│     │    │                                                                         │   │  │
│     │    │ 结果: code = [5, 6, 7, 5, 8, 4, 9, 3, 10, ..., 5]  (27个数字)         │   │  │
│     │    └────────────────────────────────────────────────────────────────────────┘   │  │
│     │                                                                                   │  │
│     │ 3. 计算适应度: calculationFitness(NectraSource[i].code, ...)                     │  │
│     │    ┌──────────────────────────────────────────────────────────────────────┐     │  │
│     │    │ 3.1 根据 code 构建剪枝模型                                            │     │  │
│     │    │     model = resnet(cfg, honey=code)                                   │     │  │
│     │    │                                                                       │     │  │
│     │    │ 3.2 加载预训练权重 (权重继承)                                         │     │  │
│     │    │     load_resnet_honey_model(model, args.random_rule)                 │     │  │
│     │    │                                                                       │     │  │
│     │    │ 3.3 FOR循环 1.1.1: 训练 calfitness_epoch 轮                           │     │  │
│     │    │     ┌─────────────────────────────────────────────────────────────┐  │     │  │
│     │    │     │ for epoch in range(args.calfitness_epoch):  # 例如 2 轮    │  │     │  │
│     │    │     │     ┌───────────────────────────────────────────────────┐  │  │     │  │
│     │    │     │     │ FOR循环 1.1.1.1: 遍历训练数据                      │  │  │     │  │
│     │    │     │     │ ─────────────────────────────────────────────────│  │  │     │  │
│     │    │     │     │ for batch, (inputs, targets) in train_loader:   │  │  │     │  │
│     │    │     │     │     output = model(inputs)                       │  │  │     │  │
│     │    │     │     │     loss = loss_func(output, targets)            │  │  │     │  │
│     │    │     │     │     loss.backward()                               │  │  │     │  │
│     │    │     │     │     optimizer.step()                              │  │  │     │  │
│     │    │     │     └───────────────────────────────────────────────────┘  │  │     │  │
│     │    │     └─────────────────────────────────────────────────────────────┘  │     │  │
│     │    │                                                                       │     │  │
│     │    │ 3.4 FOR循环 1.1.2: 在测试集上评估                                     │     │  │
│     │    │     ┌─────────────────────────────────────────────────────────────┐  │     │  │
│     │    │     │ for batch_idx, (inputs, targets) in testLoader:            │  │     │  │
│     │    │     │     outputs = model(inputs)                                 │  │     │  │
│     │    │     │     predicted = accuracy(outputs, targets)                  │  │     │  │
│     │    │     │     fit_accurary.update(predicted[0], inputs.size(0))       │  │     │  │
│     │    │     └─────────────────────────────────────────────────────────────┘  │     │  │
│     │    │                                                                       │     │  │
│     │    │ 返回: fit_accurary.avg  (例如 85.3%)                                  │     │  │
│     │    └──────────────────────────────────────────────────────────────────────┘     │  │
│     │                                                                                   │  │
│     │ 4. 保存适应度:                                                                    │  │
│     │    NectraSource[i].fitness = 85.3%                                                │  │
│     │    NectraSource[i].trail = 0                                                      │  │
│     │                                                                                   │  │
│     │ 5. 复制到雇佣蜂和观察蜂:                                                          │  │
│     │    EmployedBee[i].code = copy.deepcopy(NectraSource[i].code)                     │  │
│     │    OnLooker[i].code = copy.deepcopy(NectraSource[i].code)                        │  │
│     └──────────────────────────────────────────────────────────────────────────────────┘  │
└────────────────────────────────────────────────────────────────────────────────────────────┘
                                         ↓
┌────────────────────────────────────────────────────────────────────────────────────────────┐
│ FOR循环 2: 选择初始最优解                                                                   │
│ ───────────────────────────────────────────────────────────────────────────────────────── │
│ best_index = 0                                                                             │
│ for i in range(1, args.food_number):                                                       │
│     if NectraSource[i].fitness > NectraSource[best_index].fitness:                         │
│         best_index = i                                                                     │
│                                                                                            │
│ best_honey.code = copy.deepcopy(NectraSource[best_index].code)                            │
│ best_honey.fitness = NectraSource[best_index].fitness                                      │
│                                                                                            │
│ 结果: best_honey.fitness = 85.3% (来自食物源1)                                             │
└────────────────────────────────────────────────────────────────────────────────────────────┘

═══════════════════════════════════════════════════════════════════════════════════════════════
                        阶段 2: ABC 搜索主循环 (max_cycle 次迭代)
═══════════════════════════════════════════════════════════════════════════════════════════════

┌────────────────────────────────────────────────────────────────────────────────────────────┐
│ FOR循环 3: ABC 主搜索周期                                                                   │
│ ───────────────────────────────────────────────────────────────────────────────────────── │
│ no_improvement_cycles = 0                                                                  │
│ last_best_fitness = best_honey.fitness                                                     │
│                                                                                            │
│ for cycle in range(args.max_cycle):  # 例如 max_cycle = 10                                │
│     ┌──────────────────────────────────────────────────────────────────────────────────┐ │
│     │ Cycle 0, 1, 2, ..., 9                                                             │ │
│     │                                                                                   │ │
│     │ ┌───────────────────────────────────────────────────────────────────────────┐   │ │
│     │ │ 2.1 雇佣蜂阶段: sendEmployedBees()                                         │   │ │
│     │ │ ─────────────────────────────────────────────────────────────────────────│   │ │
│     │ │ FOR循环 3.1: 派遣所有雇佣蜂                                                │   │ │
│     │ │ ┌─────────────────────────────────────────────────────────────────────┐  │   │ │
│     │ │ │ for i in range(args.food_number):  # 遍历所有食物源                 │  │   │ │
│     │ │ │     ┌───────────────────────────────────────────────────────────┐  │  │   │ │
│     │ │ │     │ 雇佣蜂 i 的搜索流程:                                       │  │  │   │ │
│     │ │ │     │                                                           │  │  │   │ │
│     │ │ │     │ 1. 选择另一个食物源 k:                                    │  │  │   │ │
│     │ │ │     │    while True:                                            │  │  │   │ │
│     │ │ │     │        k = random.randint(0, food_number-1)               │  │  │   │ │
│     │ │ │     │        if k != i: break                                   │  │  │   │ │
│     │ │ │     │                                                           │  │  │   │ │
│     │ │ │     │ 2. 复制当前食物源编码:                                    │  │  │   │ │
│     │ │ │     │    EmployedBee[i].code = copy(NectraSource[i].code)      │  │  │   │ │
│     │ │ │     │                                                           │  │  │   │ │
│     │ │ │     │ 3. 随机选择要变异的维度:                                  │  │  │   │ │
│     │ │ │     │    param2change = randint(0, dimension-1, honeychange_num)│  │  │   │ │
│     │ │ │     │    R = uniform(-1, 1, honeychange_num)                    │  │  │   │ │
│     │ │ │     │                                                           │  │  │   │ │
│     │ │ │     │ 4. FOR循环 3.1.1: 变异选中的维度                          │  │  │   │ │
│     │ │ │     │    ┌──────────────────────────────────────────────────┐  │  │  │   │ │
│     │ │ │     │    │ for j in range(args.honeychange_num):  # 如 2次 │  │  │  │   │ │
│     │ │ │     │    │     EmployedBee[i].code[param2change[j]] =       │  │  │  │   │ │
│     │ │ │     │    │         NectraSource[i].code[param2change[j]] +  │  │  │  │   │ │
│     │ │ │     │    │         R[j] * (NectraSource[i].code[...] -      │  │  │  │   │ │
│     │ │ │     │    │                 NectraSource[k].code[...])       │  │  │  │   │ │
│     │ │ │     │    │                                                  │  │  │  │   │ │
│     │ │ │     │    │     # 边界检查                                   │  │  │  │   │ │
│     │ │ │     │    │     if code < 1: code = 1                        │  │  │  │   │ │
│     │ │ │     │    │     if code > max_preserve: code = max_preserve  │  │  │  │   │ │
│     │ │ │     │    └──────────────────────────────────────────────────┘  │  │  │   │ │
│     │ │ │     │                                                           │  │  │   │ │
│     │ │ │     │ 5. 计算新解的适应度:                                      │  │  │   │ │
│     │ │ │     │    EmployedBee[i].fitness =                               │  │  │   │ │
│     │ │ │     │        calculationFitness(EmployedBee[i].code, ...)       │  │  │   │ │
│     │ │ │     │    (内部包含训练和测试循环，见前面 calculationFitness)    │  │  │   │ │
│     │ │ │     │                                                           │  │  │   │ │
│     │ │ │     │ 6. 贪婪选择:                                              │  │  │   │ │
│     │ │ │     │    if EmployedBee[i].fitness > NectraSource[i].fitness:   │  │  │   │ │
│     │ │ │     │        NectraSource[i] = EmployedBee[i]                   │  │  │   │ │
│     │ │ │     │        NectraSource[i].trail = 0  # 重置未改进计数        │  │  │   │ │
│     │ │ │     │    else:                                                  │  │  │   │ │
│     │ │ │     │        NectraSource[i].trail += 1  # 增加未改进计数       │  │  │   │ │
│     │ │ │     └───────────────────────────────────────────────────────────┘  │  │   │ │
│     │ │ └─────────────────────────────────────────────────────────────────────┘  │   │ │
│     │ └───────────────────────────────────────────────────────────────────────────┘   │ │
│     │                                                                                   │ │
│     │ ┌───────────────────────────────────────────────────────────────────────────┐   │ │
│     │ │ 2.2 计算概率阶段: calculateProbabilities()                                 │   │ │
│     │ │ ─────────────────────────────────────────────────────────────────────────│   │ │
│     │ │ FOR循环 3.2: 计算相对适应度                                                │   │ │
│     │ │ ┌─────────────────────────────────────────────────────────────────────┐  │   │ │
│     │ │ │ # 1. 先找最大适应度                                                 │  │   │ │
│     │ │ │ maxfit = NectraSource[0].fitness                                    │  │   │ │
│     │ │ │ for i in range(1, args.food_number):                                │  │   │ │
│     │ │ │     if NectraSource[i].fitness > maxfit:                            │  │   │ │
│     │ │ │         maxfit = NectraSource[i].fitness                            │  │   │ │
│     │ │ │                                                                     │  │   │ │
│     │ │ │ # 2. 计算每个食物源的相对适应度                                     │  │   │ │
│     │ │ │ for i in range(args.food_number):                                   │  │   │ │
│     │ │ │     NectraSource[i].rfitness =                                      │  │   │ │
│     │ │ │         0.9 * (NectraSource[i].fitness / maxfit) + 0.1              │  │   │ │
│     │ │ │                                                                     │  │   │ │
│     │ │ │ 结果: rfitness ∈ [0.1, 1.0]                                         │  │   │ │
│     │ │ └─────────────────────────────────────────────────────────────────────┘  │   │ │
│     │ └───────────────────────────────────────────────────────────────────────────┘   │ │
│     │                                                                                   │ │
│     │ ┌───────────────────────────────────────────────────────────────────────────┐   │ │
│     │ │ 2.3 观察蜂阶段: sendOnlookerBees()                                         │   │ │
│     │ │ ─────────────────────────────────────────────────────────────────────────│   │ │
│     │ │ 轮盘赌选择机制:                                                            │   │ │
│     │ │ ┌─────────────────────────────────────────────────────────────────────┐  │   │ │
│     │ │ │ i = 0  # 当前食物源索引                                             │  │   │ │
│     │ │ │ t = 0  # 已派遣的观察蜂数量                                         │  │   │ │
│     │ │ │                                                                     │  │   │ │
│     │ │ │ WHILE循环 3.3: 派遣观察蜂                                           │  │   │ │
│     │ │ │ ┌───────────────────────────────────────────────────────────────┐  │  │   │ │
│     │ │ │ │ while t < args.food_number:  # 派遣 food_number 只观察蜂      │  │  │   │ │
│     │ │ │ │     R_choosed = random.uniform(0, 1)                          │  │  │   │ │
│     │ │ │ │                                                               │  │  │   │ │
│     │ │ │ │     if R_choosed < NectraSource[i].rfitness:                  │  │  │   │ │
│     │ │ │ │         # 选中食物源 i                                        │  │  │   │ │
│     │ │ │ │         t += 1                                                │  │  │   │ │
│     │ │ │ │                                                               │  │  │   │ │
│     │ │ │ │         # 选择另一个食物源 k                                  │  │  │   │ │
│     │ │ │ │         while True:                                           │  │  │   │ │
│     │ │ │ │             k = random.randint(0, food_number-1)              │  │  │   │ │
│     │ │ │ │             if k != i: break                                  │  │  │   │ │
│     │ │ │ │                                                               │  │  │   │ │
│     │ │ │ │         OnLooker[i].code = copy(NectraSource[i].code)        │  │  │   │ │
│     │ │ │ │         param2change = randint(0, dimension-1, honeychange_num)│ │  │   │ │
│     │ │ │ │         R = uniform(-1, 1, honeychange_num)                   │  │  │   │ │
│     │ │ │ │                                                               │  │  │   │ │
│     │ │ │ │         FOR循环 3.3.1: 变异观察蜂的编码                       │  │  │   │ │
│     │ │ │ │         ┌─────────────────────────────────────────────────┐  │  │  │   │ │
│     │ │ │ │         │ for j in range(args.honeychange_num):           │  │  │  │   │ │
│     │ │ │ │         │     OnLooker[i].code[param2change[j]] =         │  │  │  │   │ │
│     │ │ │ │         │         NectraSource[i].code[...] +             │  │  │  │   │ │
│     │ │ │ │         │         R[j] * (NectraSource[i].code[...] -     │  │  │  │   │ │
│     │ │ │ │         │                 NectraSource[k].code[...])      │  │  │  │   │ │
│     │ │ │ │         │     # 边界检查                                  │  │  │  │   │ │
│     │ │ │ │         │     if code < 1: code = 1                       │  │  │  │   │ │
│     │ │ │ │         │     if code > max_preserve: code = max_preserve │  │  │  │   │ │
│     │ │ │ │         └─────────────────────────────────────────────────┘  │  │  │   │ │
│     │ │ │ │                                                               │  │  │   │ │
│     │ │ │ │         # 计算适应度                                          │  │  │   │ │
│     │ │ │ │         OnLooker[i].fitness =                                 │  │  │   │ │
│     │ │ │ │             calculationFitness(OnLooker[i].code, ...)         │  │  │   │ │
│     │ │ │ │                                                               │  │  │   │ │
│     │ │ │ │         # 贪婪选择                                            │  │  │   │ │
│     │ │ │ │         if OnLooker[i].fitness > NectraSource[i].fitness:     │  │  │   │ │
│     │ │ │ │             NectraSource[i] = OnLooker[i]                     │  │  │   │ │
│     │ │ │ │             NectraSource[i].trail = 0                         │  │  │   │ │
│     │ │ │ │         else:                                                 │  │  │   │ │
│     │ │ │ │             NectraSource[i].trail += 1                        │  │  │   │ │
│     │ │ │ │                                                               │  │  │   │ │
│     │ │ │ │     # 移动到下一个食物源 (循环)                               │  │  │   │ │
│     │ │ │ │     i += 1                                                    │  │  │   │ │
│     │ │ │ │     if i == args.food_number:                                 │  │  │   │ │
│     │ │ │ │         i = 0  # 回到第一个食物源                             │  │  │   │ │
│     │ │ │ └───────────────────────────────────────────────────────────────┘  │  │   │ │
│     │ │ └─────────────────────────────────────────────────────────────────────┘  │   │ │
│     │ └───────────────────────────────────────────────────────────────────────────┘   │ │
│     │                                                                                   │ │
│     │ ┌───────────────────────────────────────────────────────────────────────────┐   │ │
│     │ │ 2.4 侦察蜂阶段: sendScoutBees()                                            │   │ │
│     │ │ ─────────────────────────────────────────────────────────────────────────│   │ │
│     │ │ FOR循环 3.4: 找到 trail 最大的食物源                                       │   │ │
│     │ │ ┌─────────────────────────────────────────────────────────────────────┐  │   │ │
│     │ │ │ maxtrailindex = 0                                                   │  │   │ │
│     │ │ │ for i in range(args.food_number):                                   │  │   │ │
│     │ │ │     if NectraSource[i].trail > NectraSource[maxtrailindex].trail:   │  │   │ │
│     │ │ │         maxtrailindex = i                                           │  │   │ │
│     │ │ │                                                                     │  │   │ │
│     │ │ │ if NectraSource[maxtrailindex].trail >= args.food_limit:            │  │   │ │
│     │ │ │     # 放弃该食物源，重新初始化                                      │  │   │ │
│     │ │ │                                                                     │  │   │ │
│     │ │ │     FOR循环 3.4.1: 生成新的随机编码                                 │  │   │ │
│     │ │ │     ┌───────────────────────────────────────────────────────────┐  │  │   │ │
│     │ │ │     │ for j in range(food_dimension):                           │  │  │   │ │
│     │ │ │     │     R = random.uniform(0, 1)                              │  │  │   │ │
│     │ │ │     │     NectraSource[maxtrailindex].code[j] =                 │  │  │   │ │
│     │ │ │     │         int(R * args.max_preserve)                        │  │  │   │ │
│     │ │ │     │     if code == 0: code = 1                                │  │  │   │ │
│     │ │ │     └───────────────────────────────────────────────────────────┘  │  │   │ │
│     │ │ │                                                                     │  │   │ │
│     │ │ │     NectraSource[maxtrailindex].trail = 0                           │  │   │ │
│     │ │ │     NectraSource[maxtrailindex].fitness =                           │  │   │ │
│     │ │ │         calculationFitness(NectraSource[maxtrailindex].code, ...)   │  │   │ │
│     │ │ └─────────────────────────────────────────────────────────────────────┘  │   │ │
│     │ └───────────────────────────────────────────────────────────────────────────┘   │ │
│     │                                                                                   │ │
│     │ ┌───────────────────────────────────────────────────────────────────────────┐   │ │
│     │ │ 2.5 记忆最优解: memorizeBestSource()                                       │   │ │
│     │ │ ─────────────────────────────────────────────────────────────────────────│   │ │
│     │ │ FOR循环 3.5: 更新全局最优解                                                │   │ │
│     │ │ ┌─────────────────────────────────────────────────────────────────────┐  │   │ │
│     │ │ │ old_best_fitness = best_honey.fitness                               │  │   │ │
│     │ │ │                                                                     │  │   │ │
│     │ │ │ for i in range(args.food_number):                                   │  │   │ │
│     │ │ │     if NectraSource[i].fitness > best_honey.fitness:                │  │   │ │
│     │ │ │         best_honey.code = copy(NectraSource[i].code)                │  │   │ │
│     │ │ │         best_honey.fitness = NectraSource[i].fitness                │  │   │ │
│     │ │ │         # 保存最优模型权重                                          │  │   │ │
│     │ │ │         best_honey_state = model.state_dict()                       │  │   │ │
│     │ │ └─────────────────────────────────────────────────────────────────────┘  │   │ │
│     │ └───────────────────────────────────────────────────────────────────────────┘   │ │
│     │                                                                                   │ │
│     │ ┌───────────────────────────────────────────────────────────────────────────┐   │ │
│     │ │ 2.6 早停检查                                                               │   │ │
│     │ │ ─────────────────────────────────────────────────────────────────────────│   │ │
│     │ │ if best_honey.fitness > last_best_fitness:                                 │   │ │
│     │ │     no_improvement_cycles = 0                                              │   │ │
│     │ │     last_best_fitness = best_honey.fitness                                 │   │ │
│     │ │ else:                                                                      │   │ │
│     │ │     no_improvement_cycles += 1                                             │   │ │
│     │ │     if no_improvement_cycles >= 3:  # early_stop_patience                 │   │ │
│     │ │         print('Early stopping!')                                           │   │ │
│     │ │         break  # 跳出 for cycle 循环                                       │   │ │
│     │ └───────────────────────────────────────────────────────────────────────────┘   │ │
│     └──────────────────────────────────────────────────────────────────────────────────┘ │
└────────────────────────────────────────────────────────────────────────────────────────────┘
# 结束 for cycle 循环
# ABC 搜索完成，得到 best_honey.code 和 best_honey_state

═══════════════════════════════════════════════════════════════════════════════════════════════
                        阶段 3: 构建最优剪枝模型
═══════════════════════════════════════════════════════════════════════════════════════════════

    ┌───────────────────────────────────────────────────────────────┐
    │ 根据最优编码构建模型:                                          │
    │ model = resnet(args.cfg, honey=best_honey.code)               │
    │ model.load_state_dict(best_honey_state)                       │
    │                                                               │
    │ 保存剪枝模型:                                                  │
    │ checkpoint.save_honey_model(model.state_dict())               │
    │ → job_dir/checkpoint/bestmodel_after_bee.pt                   │
    └───────────────────────────┬───────────────────────────────────┘
                                ↓
    ┌───────────────────────────────────────────────────────────────┐
    │ 创建优化器和学习率调度器:                                      │
    │ optimizer = SGD(model.parameters(), lr, momentum, weight_decay)│
    │ scheduler = MultiStepLR(optimizer, lr_decay_step, gamma=0.1)  │
    └───────────────────────────────────────────────────────────────┘

═══════════════════════════════════════════════════════════════════════════════════════════════
                        阶段 4: 微调训练 (Fine-tuning)
═══════════════════════════════════════════════════════════════════════════════════════════════

┌────────────────────────────────────────────────────────────────────────────────────────────┐
│ FOR循环 4: 微调训练主循环                                                                   │
│ ───────────────────────────────────────────────────────────────────────────────────────── │
│ best_acc = 0.0                                                                             │
│ best_epoch = 0                                                                             │
│                                                                                            │
│ for epoch in range(start_epoch, args.num_epochs):  # 例如 [0, 150)                        │
│     ┌──────────────────────────────────────────────────────────────────────────────────┐ │
│     │ Epoch 0, 1, 2, ..., 149                                                           │ │
│     │                                                                                   │ │
│     │ ┌───────────────────────────────────────────────────────────────────────────┐   │ │
│     │ │ 4.1 训练阶段: train(model, optimizer, trainLoader, args, epoch)           │   │ │
│     │ │ ─────────────────────────────────────────────────────────────────────────│   │ │
│     │ │ model.train()                                                             │   │ │
│     │ │                                                                           │   │ │
│     │ │ FOR循环 4.1: 遍历训练数据                                                  │   │ │
│     │ │ ┌─────────────────────────────────────────────────────────────────────┐  │   │ │
│     │ │ │ for batch, (inputs, targets) in enumerate(trainLoader):            │  │   │ │
│     │ │ │     # 数据移到 GPU                                                  │  │   │ │
│     │ │ │     inputs, targets = inputs.to(device), targets.to(device)        │  │   │ │
│     │ │ │                                                                     │  │   │ │
│     │ │ │     # 清零梯度                                                      │  │   │ │
│     │ │ │     optimizer.zero_grad()                                           │  │   │ │
│     │ │ │                                                                     │  │   │ │
│     │ │ │     # 前向传播                                                      │  │   │ │
│     │ │ │     output = model(inputs)                                          │  │   │ │
│     │ │ │                                                                     │  │   │ │
│     │ │ │     # 计算损失                                                      │  │   │ │
│     │ │ │     loss = loss_func(output, targets)                               │  │   │ │
│     │ │ │                                                                     │  │   │ │
│     │ │ │     # 反向传播                                                      │  │   │ │
│     │ │ │     loss.backward()                                                 │  │   │ │
│     │ │ │                                                                     │  │   │ │
│     │ │ │     # 更新参数                                                      │  │   │ │
│     │ │ │     optimizer.step()                                                │  │   │ │
│     │ │ │                                                                     │  │   │ │
│     │ │ │     # 计算准确率                                                    │  │   │ │
│     │ │ │     prec1 = utils.accuracy(output, targets)                         │  │   │ │
│     │ │ │     accurary.update(prec1[0], inputs.size(0))                       │  │   │ │
│     │ │ │                                                                     │  │   │ │
│     │ │ │     # 定期打印训练信息                                              │  │   │ │
│     │ │ │     if batch % print_freq == 0 and batch != 0:                     │  │   │ │
│     │ │ │         logger.info('Epoch[{}] ({}/{})...')                         │  │   │ │
│     │ │ └─────────────────────────────────────────────────────────────────────┘  │   │ │
│     │ └───────────────────────────────────────────────────────────────────────────┘   │ │
│     │                                                                                   │ │
│     │ ┌───────────────────────────────────────────────────────────────────────────┐   │ │
│     │ │ 4.2 学习率衰减: scheduler.step()                                           │   │ │
│     │ │ ─────────────────────────────────────────────────────────────────────────│   │ │
│     │ │ if epoch in lr_decay_step:  # 例如 [50, 100]                              │   │ │
│     │ │     lr = lr × 0.1                                                         │   │ │
│     │ └───────────────────────────────────────────────────────────────────────────┘   │ │
│     │                                                                                   │ │
│     │ ┌───────────────────────────────────────────────────────────────────────────┐   │ │
│     │ │ 4.3 测试阶段: test_acc = test(model, testLoader)                          │   │ │
│     │ │ ─────────────────────────────────────────────────────────────────────────│   │ │
│     │ │ model.eval()                                                              │   │ │
│     │ │                                                                           │   │ │
│     │ │ FOR循环 4.3: 遍历测试数据                                                  │   │ │
│     │ │ ┌─────────────────────────────────────────────────────────────────────┐  │   │ │
│     │ │ │ with torch.no_grad():                                               │  │   │ │
│     │ │ │     for batch_idx, (inputs, targets) in enumerate(testLoader):     │  │   │ │
│     │ │ │         inputs, targets = inputs.to(device), targets.to(device)    │  │   │ │
│     │ │ │                                                                     │  │   │ │
│     │ │ │         # 前向传播                                                  │  │   │ │
│     │ │ │         outputs = model(inputs)                                     │  │   │ │
│     │ │ │                                                                     │  │   │ │
│     │ │ │         # 计算损失                                                  │  │   │ │
│     │ │ │         loss = loss_func(outputs, targets)                          │  │   │ │
│     │ │ │                                                                     │  │   │ │
│     │ │ │         # 计算准确率                                                │  │   │ │
│     │ │ │         predicted = utils.accuracy(outputs, targets)                │  │   │ │
│     │ │ │         accurary.update(predicted[0], inputs.size(0))               │  │   │ │
│     │ │ │                                                                     │  │   │ │
│     │ │ │ return accurary.avg                                                 │  │   │ │
│     │ │ └─────────────────────────────────────────────────────────────────────┘  │   │ │
│     │ └───────────────────────────────────────────────────────────────────────────┘   │ │
│     │                                                                                   │ │
│     │ ┌───────────────────────────────────────────────────────────────────────────┐   │ │
│     │ │ 4.4 保存检查点                                                             │   │ │
│     │ │ ─────────────────────────────────────────────────────────────────────────│   │ │
│     │ │ # 判断是否是最优模型                                                       │   │ │
│     │ │ is_best = (best_acc < test_acc)                                           │   │ │
│     │ │ if is_best:                                                               │   │ │
│     │ │     best_epoch = epoch                                                    │   │ │
│     │ │     logger.info('*** New best model found at epoch {} ***')               │   │ │
│     │ │ best_acc = max(best_acc, test_acc)                                        │   │ │
│     │ │                                                                           │   │ │
│     │ │ # 构建检查点字典                                                          │   │ │
│     │ │ state = {                                                                 │   │ │
│     │ │     'state_dict': model.state_dict(),                                     │   │ │
│     │ │     'best_acc': best_acc,                                                 │   │ │
│     │ │     'optimizer': optimizer.state_dict(),                                  │   │ │
│     │ │     'scheduler': scheduler.state_dict(),                                  │   │ │
│     │ │     'epoch': epoch + 1,                                                   │   │ │
│     │ │     'honey_code': code                                                    │   │ │
│     │ │ }                                                                         │   │ │
│     │ │                                                                           │   │ │
│     │ │ # 保存检查点                                                              │   │ │
│     │ │ checkpoint.save_model(state, epoch + 1, is_best)                          │   │ │
│     │ │ → 保存为 model_{epoch+1}.pt                                               │   │ │
│     │ │ → 如果 is_best，同时保存为 model_best.pt                                  │   │ │
│     │ └───────────────────────────────────────────────────────────────────────────┘   │ │
│     └──────────────────────────────────────────────────────────────────────────────────┘ │
└────────────────────────────────────────────────────────────────────────────────────────────┘
# 结束 for epoch 循环
# 微调训练完成

═══════════════════════════════════════════════════════════════════════════════════════════════
                                    训练完成
═══════════════════════════════════════════════════════════════════════════════════════════════

    ┌───────────────────────────────────────────────────────────────┐
    │ 打印最终结果:                                                  │
    │ logger.info('Best accurary: {:.3f} at epoch {}'               │
    │              .format(best_acc, best_epoch))                   │
    │                                                               │
    │ 输出文件:                                                      │
    │ ├── checkpoint/                                               │
    │ │   ├── bestmodel_after_bee.pt  (ABC搜索后的最优剪枝模型)     │
    │ │   ├── model_best.pt           (微调后的最优模型)            │
    │ │   ├── model_1.pt, model_2.pt, ...                          │
    │ │   └── model_150.pt                                          │
    │ ├── logger.log                  (完整训练日志)                │
    │ └── config.txt                  (参数配置)                    │
    └───────────────────────────────────────────────────────────────┘

═══════════════════════════════════════════════════════════════════════════════════════════════
                                  循环嵌套总结
═══════════════════════════════════════════════════════════════════════════════════════════════

总共的循环层级结构:

1. FOR循环 1: 初始化食物源 (i in range(food_number))
   └─ FOR循环 1.1: 生成编码维度 (j in range(food_dimension))
   └─ calculationFitness():
      └─ FOR循环 1.1.1: 训练轮数 (epoch in range(calfitness_epoch))
         └─ FOR循环 1.1.1.1: 训练批次 (batch in trainLoader)
      └─ FOR循环 1.1.2: 测试批次 (batch in testLoader)

2. FOR循环 2: 选择初始最优 (i in range(1, food_number))

3. FOR循环 3: ABC主循环 (cycle in range(max_cycle))
   └─ FOR循环 3.1: 雇佣蜂 (i in range(food_number))
      └─ FOR循环 3.1.1: 变异维度 (j in range(honeychange_num))
      └─ calculationFitness() [包含嵌套训练和测试循环]

   └─ FOR循环 3.2: 计算最大适应度 (i in range(food_number))
   └─ FOR循环 3.2.1: 计算相对适应度 (i in range(food_number))

   └─ WHILE循环 3.3: 观察蜂 (t < food_number)
      └─ FOR循环 3.3.1: 变异维度 (j in range(honeychange_num))
      └─ calculationFitness() [包含嵌套训练和测试循环]

   └─ FOR循环 3.4: 找最大trail (i in range(food_number))
      └─ FOR循环 3.4.1: 生成新编码 (j in range(food_dimension))
      └─ calculationFitness() [包含嵌套训练和测试循环]

   └─ FOR循环 3.5: 更新全局最优 (i in range(food_number))

4. FOR循环 4: 微调训练 (epoch in range(num_epochs))
   └─ FOR循环 4.1: 训练批次 (batch in trainLoader)
   └─ FOR循环 4.3: 测试批次 (batch in testLoader)

═══════════════════════════════════════════════════════════════════════════════════════════════

最深嵌套层级: 5 层

例如: FOR循环3 → FOR循环3.1 → calculationFitness() → FOR循环1.1.1 → FOR循环1.1.1.1

═══════════════════════════════════════════════════════════════════════════════════════════════
                                      END
═══════════════════════════════════════════════════════════════════════════════════════════════
